# Wallet Setup

To manage your accounts, issue orders, and perform other operations that are required to be signed, a Wallet is required.

A Wallet is setup using your secret __mnemonic__ phrase. Please see this [guide](/todo) on how to get it.

:::warning
Handle your __mnemonic__ in a secure manner. __Do not share__ it with other parties. Access to your __mnemonic__ provides access to your account and funds. 
:::

:::details[Unification Plan]
- The Python client requires the use of an address to setup the Wallet. However, the address can only be fetched using a Wallet. The address is derived from the mnemonic (address < public key < private key < mnemonic).
- Wallet, accounts, subaccounts are all handled differently among the clients. Probably the Rust client handles this best, giving the user more control:
    1. There is a `Wallet`;
    2. The `Wallet` is used to derive an `Account` by index (each `Account` is associated with a keypair);
    3. An `Account` is used to derive a `Subaccount` by index. A `Subaccount` is employed to create orders.  
:::

::::steps


## Read the mnemonic

Load the mnemonic into a string variable. This assumes the mnemonic is stored in a text file.

:::code-group

```python [Python]
mnemonic = open('mnemonic.txt').read().strip()
```

```typescript [TypeScript]
const mnemonic = require('fs').readFileSync('mnemonic.txt', 'utf8').trim();
```

```rust [Rust]
let mnemonic = std::fs::read_to_string("mnemonic.txt").unwrap().trim().to_string();
```

:::

## Create the Wallet

Use the __mnemonic__ to create a Wallet instance capable of signing transactions.

:::code-group

```python [Python]
from dydx_v4_client.key_pair import KeyPair
from dydx_v4_client.node.client import NodeClient
from dydx_v4_client.wallet import Wallet

# Define the dYdX node endpoint.
endpoint = "..."

# Define your address.
address = Wallet(KeyPair.from_mnemonic(mnemonic), 0, 0).address()

# Create a `NodeClient` instance which connects to the dYdX network.
node = await NodeClient.connect(endpoint)

# Create a Wallet with updated parameters required for trading
wallet = await Wallet.from_mnemonic(node, mnemonic, address)
```

```typescript [TypeScript]
import { BECH32_PREFIX, LocalWallet } from '@dydxprotocol/v4-client-js';

const wallet = await LocalWallet.fromMnemonic(mnemonic, BECH32_PREFIX);
```

```rust [Rust]
use dydx::node::Wallet;

let wallet = Wallet::from_mnemonic(&mnemonic)?;
```

:::

## Instantiate a Subaccount

:::note
This step is not required in the Python client.
:::

When issuing orders, the relevant Subaccount must be chosen to place the order under. A Subaccount is associated with an Account, and is meant to provide trade isolation against your other Subaccounts and enhance funds management.
See more about accounts and subaccounts [here](/todo).

:::code-group

```python [Python]
# Not required. The `wallet` instance created above already contains the necessary information.
# The Subaccount to be used is defined using an integer when creating an order.
```

```typescript [TypeScript]
import { SubaccountInfo } from '../src/clients/subaccount';

const subaccount = new SubaccountInfo(wallet, 0);
```

```rust [Rust]
use dydx::config::ClientConfig;
use dydx::node::NodeClient;

// Read the configuration file containing parameters such as the node endpoints.
let config = ClientConfig::from_file("config.toml").await?;

// Create a `NodeClient` instance which connects to the dYdX network.
let client = NodeClient::connect(config.node).await?;

// Create an `Account` instance for the account index 0. This `Account` has updated parameters required for trading.
let mut account = wallet.account(0, &mut placer.client).await?;

// Create a `Subaccount` instance for the subaccount index 0.
let subaccount = account.subaccount(0)?;
```

:::

:::info
By default, both Python and TypeScript client Wallets will derive and use the Account indexed at 0.
:::

